---
title: 算法分析概述
date: 2022-06-13 16:16:06
math: true
categories:
  - [数据结构和算法]
tags:
  - 算法分析
  - 数据结构和算法
  - 时间复杂度
---

本文是数据结构和算法专题中的算法分析，详细讲解各种算法的时间复杂分析。

<!-- more -->

<div class="note note-primary">

**这个专题使用什么语言？**

如果没有特别说明，整个数据结构和算法专题将使用 **Python 和 C++ 实现各种算法** 。原因如下：
- 本文不会陷入使用哪种语言更好的争端，Java、Py 各有所爱，使用哪种语言取决于你自己
- 使用一门语言意味着片面，我们需要综合考虑，相互比较，这是一个有意思的过程
- 使用两门语言的文章读者会多于一门语言
- Python 相当简洁且优雅，对于快速实现算法
- C++ 是竞赛、教学、大型工程的主流语言

本文将优先选择 Python 语言编写算法和数据结构，原因是 Python 程序比 C++ 易读，也更容易理解从而被接受。

</div>

# 1. 什么是算法分析

## 1.1 算法分析的目标

本文的 “算法分析” 不仅仅指分析算法，也对一些数据结构操作进行探讨，为了比较哪些算法或数据结构是设计优秀、优雅的，我们需要使用一些分析算法的方法。

通常，我们可以使用时间来度量算法的性能。实际上，时间是一个良好的度量单位，因为计算机中最重要的资源是时间，进行一些大任务通常需要花费计算机很多时间。但是，计算机的运行时间是一个不准确的度量，因为算法的运行时间通常受到数据规模大小的影响，并且和计算机此时的运行状态、计算机的性能、操作系统、设计语言、CPU 架构和一些随机因素影响。

在相当多的场合下，这些也是一个算法能否应用到实际上需要考虑的内容，但是尽管有来自不同方面的干扰，我们最关注的还是算法有多大程度上受到数据规模的影响，并希望使用数学的方法进行理论分析，此时我们排除了真实情况的计算机执行情况。

## 1.2 实验结果

如果算法已经实现，那么在进行数学分析之前，我们可以进行实际运行来计算它到底进行了多长的时间。

下面的代码将计算 `for` 循环 $100000000$ 次所花费的秒数：

```python
from time import time

start = time()
for i in range(100000000):
    pass
end = time()
print(end - start)
# 5.468473672866821
```
```c++
#include <ctime>
#include <iostream>
using namespace std;

int main() {
    clock_t start, finish;
    start = clock();
    for (int i = 0; i < 100000000; i++)
        ;
    float sec = (float)(clock() - start) / CLOCKS_PER_SEC;
    finish = clock();
    cout << "time: " << sec << endl;
    // time: 0.219
    return 0;
}
```

结果的差距是显而易见的。

<div class="note note-success">

Python 的标准库中有专门进行算法时间测试的库 `timeit`，`timeit` 会进行大量重复实验来消除随机性误差。

</div>


# 2. 算法分析的数学基础

# 3. 算法的渐进分析

## 1. 复杂度定义

时间复杂度和空间复杂度是衡量一个算法效率的重要标准。

简单来说，渐进符号忽略了一个函数中增长较慢的部分以及各项的系数（在时间复杂度相关分析中，系数一般被称作 “常数”），而保留了可以用来表明该函数增长趋势的重要部分。

> 像 $f(n) = \Theta(g(n))$ 的写法是不严谨的，也不可以写为 $\Theta(g(n)) = f(n)$ 。从定义上讲，更合理的写法是 $f(n) \in \Theta(g(n))$ ， $\Theta(g(n))$ 代表了一类函数的集合。

对于那些执行用时和数据规模无关的语句，在本文的后面提到，它们会被看做是 $O(1)$ 的时间复杂度，假设它们的用时都是一个单位时间 $u$ ，在记号 $T$ 中，我们统计所有的时间消耗并将算法的耗时记作 $T(n)$ ，虽然这在许多地方并不严谨。

我们还需要一个假设：算法能够解决任何规模的问题，这样下面的

## 2. 大 $\Theta$ 符号

对于函数 $f(n)$ 和 $g(n)$ ，记 $f(n) = \Theta(g(n))$ ，当且仅当 $\exist\,c_1,\,c_2,\,n_0 > 0$ ，使得 $\forall\, n \ge n_0,\, 0 \le c_1 \cdot g(n) \le f(n) \le c_2 \cdot g(n)$ 。

例如
- $3n^2 + 5n - 3 = \Theta(n^2)$
- $n\sqrt{n} + n\log^5 n + m\log m +nm = \Theta(n\sqrt{n} + m\log m + nm)$

## 3. 大 $O$ 符号

大 $O$ 符号的一些性质：
1. $\max(a_n),\,\min(a_n)$ 的时间复杂度为 $O(n)$
2. 如果 $f(n)$ 是一个指数为 $d$ 的多项式 $f(n) = a_0 + a_1n + \cdots + a_dn^d$ 那么 $f(n)$ 是 $O(n^d)$ 的
3. 



## 4. 大 $\Omega$ 符号

## 5. 小 $o$ 符号

## 6. 小 $\omega$ 符号


## 7. 常见性质

- $f(n) = \Theta(g(n)) \Leftrightarrow f(n) = O(g(n)) \cap f(n) = \Omega(g(n))$
- $f(n) + g(n) = O(\max\{f(n), g(n)\})$
- $f(n)g(n) = O(f(n)g(n))$
- $\forall\, a \neq 1,\, \log_a n = O(\log _2 n)$

由换底公式可以得知，任何对数函数无论底数为何，都具有相同的增长率，因此渐进时间复杂度中对数的底数一般省略不写。

## 8. 常量

如果 $n$ 的大小不被看作输入规模，那么这段代码的时间复杂度就是 $O(1)$ 。

需要注意的是，在进行时间复杂度相关的理论性讨论时，“算法能够解决任何规模的问题”是一个基本假设。因此，能在常量时间内解决数据规模有限的问题（例如，对于数据范围内的每个可能输入预先计算出答案）并不能使一个算法的时间复杂度变为 $O(1)$ 。

例如，我们可以预先计算答案，然后在相当大的空间储存答案，这样可以让充分多的问题变为 $O(1)$ ，这样所有答案都可以通过一个巨大的哈希表索引，这显然也是不合理的。


## 9. 几个重要结论、定理

### 9.1 主定理（Master Theorem）

假设存在递推关系

$$
T(n) = a T\left(\frac{n}{b}\right) + f(n),\,\forall n > b
$$

那么

$$
T(n) = \left\{\begin{aligned}
    & \Theta\left(n^{\log_b a}\right)\,, &&
    f(n) = O(n^{\log_b a-\epsilon}) \\
    & \Theta(f(n))\,, &&
    f(n) = \Omega(n^{\log_b a+\epsilon}) \\
    & \Theta(n^{\log_b a}\log^{k+1}n)\,, &&
    f(n) = \Theta\left(n^{\log_b a}\log^k n\right)
\end{aligned}\right.
$$

### 9.2 均摊复杂度

### 9.3 势能分析



# 4. 典型的算法分析示例

# 参考

[1] Michael T.Goodrich 等著，张晓等译，*数据结构与算法 Python 语言实现*，机械工业出版社（2018-09）

[2] 计算理论基础，oi-wiki，<https://oi-wiki.org/misc/cc-basic/>
