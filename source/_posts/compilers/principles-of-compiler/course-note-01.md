---
title: 编译原理概述
date: 2022-06-10 20:50:04
categories:
  - [编译原理, 编译原理笔记]
tags:
  - 编译原理
---

## 1-1 什么是编译

不同层次的语言：
- 高级语言
    - 编写简单，不依赖特定机器
    - 如 `x = 2`
- 汇编语言
    - 编写复杂，需要了解特定机器
    - 如 `mov x 0002`
- 机器语言
    - 可以被计算机直接理解的语言
    - 如 `C706 0000 0002`

<div class="note note-primary">

**编译**（Compile）：将 **高级语言** 翻译成 **汇编语言** 或者 **机器语言** 的过程。

</div>

编译器在语言处理系统中的位置：

<div class="center">
<img src="./svg/1-编译器在语言处理系统的位置.svg" />
</div>

- 预处理器
    - 把储存在不同文件中的源程序 **聚合** 在一起
    - 把 **宏** 转换为原始语句
- **可重定位**（Relocatable）
    - 在内存中存放的起始位置 $L$ 不是固定的
- 加载器
    - 修改可重定位地址，将修改后的指令和数据放到内存的适当位置
    - **起始位置 + 相对地址 = 绝对地址**
- 链接器
    - 将多个可重定位的机器代码文件（包括库文件）连接到一起
    - 解决外部内存地址问题
        - 指的是一个过程中的代码可能引用另一个文件的数据对象或过程，这些数据对象或过程的地址对于这个文件来说是外部地址

## 1-2 编译系统的结构

如何翻译 `"In his room, he broke a window with a hammer."` ？

$$
\begin{aligned}
    \text{源语言} &\rightarrow& \text{句子的语义}\;
    &\rightarrow&
    \text{目标语言} \\
    & (1) & \text{(中间语言)}\; & \;(2) &
\end{aligned}
$$

1. 分析源语言过程
    1. 语义分析（Semantic Analysis）
    2. 语法分析（Syntax Analysis）
    3. 词法分析（Lexical Analysis）
2. 生成目标语言

示意图：

<div class="center">
<img src="./svg/1-分析源语言过程.svg" />
</div>

- 分析部分
    - 又叫编译前端（Front End）
    - 与 **源语言** 相关
- 综合部分
    - 又叫编译后端（Back End）
    - 与 **目标语言** 相关

<div class="note note-primary">

**语法制导翻译**（Syntax-Directed Translation）：在解析输入的字符串时，在特定位置执行指定的动作。

</div>

- 换言之，根据语法把输入的字符串“翻译”为一串动作，故名“语法制导翻译”
- 编译过程多个过程是绑定在一起的

## 1-3 词法分析

- 词法分析器的作用
    - 从左到右扫描源程序的字符，识别出各个单词，确定单词的类型
    - 将识别出的单词转换为统一的 **机内表示** —— **词法单元**（Token）的形式
    - `token: <种别码, 属性值>`

| index | 单词类型 |                 种别                 |       种别码        |
| :---: | :------: | :----------------------------------: | :-----------------: |
|   1   |  关键字  | `program`、`if`、`else`、`then`、... |      一词一码       |
|   2   |  标识符  | 变量名、数组名、记录名、过程名、...  |      多词一码       |
|   3   |   常量   |  整型、浮点型、字符型、布尔型、...   |      一型一码       |
|   4   |  运算符  | 算术（`+-*/ ++ --`）关系、逻辑、...  | 一词一码 / 一型一码 |
|   5   |  界限符  |          `; ( ) = { } `...           |      一词一码       |

例如，分析下面的语句：

```c
while (value != 100) {
    num++;
}
```

词法分析的输出结果如下：
1.  `while  <WHILE, - >`
2.  `(      <SLP, - >`
3.  `value  <IDN, value>`
4.  `!=     <NE, - >`
5.  `100    <CONST, 100>`
6.  `)      <SRP, - >`
7.  `{      <LP, - >`
8.  `num    <IDN, num>`
9.  `++     <INC, - >`
10. `;      <SEMI, - >`
11. `}      <RP, - >`

## 1-4 语法分析概述

<div class="note note-primary">

**语法分析器**（Parser）：从词法分析器输出的 `token` 序列中 **识别出各类短语**，并 **构造语法分析树**（Parse Tree）。

</div>

例如：

```c
position = initial + rate * 60;
```

序列为 `<id, position> <=> <id, initial> <+> <id, rate> <*> <num, 60> <;>`

赋值语句的解析结构如下：

<div class="center">
<img src="./svg/1-赋值语句分析树.svg" />
</div>

变量声明语句的分析树

【定义】**变量声明语句文法**：

$$
\begin{aligned}
    \text{<D>} & \rightarrow  \text{<T><IDS>;} \\
    \text{<T>} & \rightarrow \text{int | real | char | bool} \\
    \text{<IDS>}&\rightarrow \text{id | <IDS>, id}
\end{aligned}
$$

输入：

```c
int a, b, c;
```

解析出的语法树如下：

<div class="center">
<img src="./svg/1-变量声明语句.svg" />
</div>

## 1-5 语义分析概述

语义分析的主要任务，收集标识符的属性信息：
- **种型**（Kind）
- **类型**（Type）
- **储存位置、长度**

```pascal
begin
    real x[8];
    integer i,j;
    ......
end
```

| 名字  | 相对地址 |
| :---: | :------: |
|  `x`  |   `0`    |
|  `i`  |   `64`   |
|  `j`  |   `68`   |

语义检查：
1. 变量或过程未经声明
2. 变量或过程重复声明
3. 运算分量类型不匹配
4. 操作符和操作符不匹配
    - 数组下标不是整数
    - 对非数组变量使用数组访问操作符
    - 对非过程名使用过程调用操作符
    - 过程调用的参数类型或数目不匹配
    - 函数返回类型有误

## 1-6 中间代码生成和编译器后端

- **三地址码**（Three-Address Code）
    - 三地址码由 **类似于汇编语言** 的指令序列组成
    - 每个指令最多有三个 **操作数**（Operand）
- **语法树**（Syntax Tree）

常见三地址码：

| 指令类型       | 指令形式                       |
| -------------- | ------------------------------ |
| 赋值指令       | `x = y op z` / `x = op y`      |
| 复制指令       | `x = y`                        |
| 条件跳转       | `if x relop y goto n`          |
| 非条件跳转     | `goto n`                       |
| 参数传递       | `param x`                      |
| 过程调用       | `call p, n`                    |
| 过程返回       | `return x`                     |
| 数组引用       | `x = y[i]`                     |
| 数组赋值       | `x[i] = y`                     |
| 地址及指针操作 | `x = &y` / `x = *y` / `*x = y` |

地址可能具有如下形式：
- 源程序中的 **名字**（Name）
- **常量**（Constant）
- 编译器生成的 **临时变量**（Temporary Variable）

三地址表示：
- **四元式**（Quadruples）
    - `(op, y, z, x)`
- **三元式**（Triples）
- **间接三元式**（Indirect Triples）

以上三地址指令的四元式表示：

```text
(op, y, z, x)
(op, y, _, x)
(=, y, _, x)
(relop, x, y, n)
(goto, _, _, n)
(param, _, _, x)
(call, p, n, _)
(return, _, _, x)
(=[], y, i, x)
([]=, y, x, i)
(&, y, _, x)
(=*, y, _, x)
(*=, y, _, x)
```

```pascal
while a < b do
    if c < 5 then
        while x > y do
            z = x + 1;
    else x = y;
```

三地址码表示（`j` 表示跳转指令）

```log
100: (j<, a, b, 102)
101: (j , -, -, 112)
102: (j<, c, 5, 104)
103: (j , -, -, 110)
104: (j>, x, y, 106)
105: (j , -, -, 100)
106: (+ , x, 1, t1 )
107: (= , t1, -, z )
108: (j , -, -, 104)
109: (j , -, -, 100)
110: (= , y, -, x  )
111: (j , -, -, 100)
112: 
```

目标代码生成的一个重要任务是为程序中使用的变量 **合理分配寄存器**。

**代码优化**：为改进代码所进行的等价程序变换，使其运行得更快一些，占用空间更小一些。
